# FlowQ — Lightweight Message Broker (MVP)

FlowQ is a minimal, modular message broker implemented in Rust. This repository contains an MVP implementation intended for experimentation, development, and as a foundation for further features (persistence backends, clustering, security, etc.).

**Status:** MVP — in-memory storage, HTTP API, basic QoS (ack/nack, visibility, retries).

**Table of Contents**

- **Overview**
- **Features**
- **Repository Layout**
- **Architecture**
- **Build & Run**
- **HTTP API Examples**
- **Library Usage (Rust)**
- **Testing**
- **Contributing**
- **License**

## Overview

FlowQ provides: lightweight queue creation, publish/consume semantics, message acknowledgement (ack/nack), per-queue configuration, and an in-memory storage backend suitable for development and tests. The server exposes a small HTTP API with OpenAPI (Swagger) documentation.

This project is intentionally modular: core logic, types, storage backends and the server are split into separate crates in the workspace so you can replace storage or extend features independently.

## Features

- Create/list/delete named queues
- Publish messages (raw text/bytes or JSON)
- Receive single or batched messages
- Ack / Nack messages (with simple retry behavior)
- Queue-level configuration (visibility timeout, TTL, retries)
- In-memory storage backend (default) — good for development and tests
- HTTP API with autogenerated OpenAPI and Swagger UI

## Repository Layout

- **[Cargo.toml](Cargo.toml)** — workspace manifest and shared dependencies
- **[crates/flowq-types](crates/flowq-types/Cargo.toml)** — shared domain types (Message, Queue, errors)
- **[crates/flowq-storage](crates/flowq-storage/Cargo.toml)** — storage engine trait + backends (feature `memory` enabled by default)
- **[crates/flowq-core](crates/flowq-core/Cargo.toml)** — core broker orchestration and message handling
- **[crates/flowq-server](crates/flowq-server/Cargo.toml)** — HTTP server (Axum) + OpenAPI/Swagger UI

Primary server entry point: [crates/flowq-server/src/main.rs](crates/flowq-server/src/main.rs)

Core broker implementation: [crates/flowq-core/src/broker.rs](crates/flowq-core/src/broker.rs)

In-memory storage implementation: [crates/flowq-storage/src/memory.rs](crates/flowq-storage/src/memory.rs)

Types and schemas: [crates/flowq-types/src/message.rs](crates/flowq-types/src/message.rs) and [crates/flowq-types/src/queue.rs](crates/flowq-types/src/queue.rs)

## Architecture (high level)

- The public API surface is small and split between two consumption models:
	- HTTP interface (Axum) in `flowq-server` for remote clients
	- Programmatic Rust usage by instantiating `flowq_core::Broker` with any `flowq_storage::StorageEngine`
- `flowq-core::Broker` contains business logic and delegates persistence to a `StorageEngine` trait implemented by `flowq-storage` backends.
- `flowq-storage` currently ships an in-memory implementation (`MemoryStorage`) suitable for tests and local development.

## Build & Run

Prerequisites: Rust toolchain (stable, tested on Rust 1.75+). Cargo will build all workspace crates.

Build (debug):

```bash
cargo build --workspace
```

Run the server (default uses in-memory storage):

```bash
cargo run -p flowq-server
```

Server will listen on `127.0.0.1:3000` by default. Swagger UI is available at:

http://localhost:3000/swagger-ui/

Health endpoint:

http://localhost:3000/health

Notes for Windows PowerShell users (if you prefer explicit):

```powershell
# Build
cargo build --workspace

# Run
cargo run -p flowq-server
```

## HTTP API Examples

Assuming the server is running on `http://localhost:3000`.

- Health check

```bash
curl -s http://localhost:3000/health | jq
```

- Create a queue

```bash
curl -X POST http://localhost:3000/api/v1/queues \
	-H 'Content-Type: application/json' \
	-d '{"name":"my-queue"}'
```

- Publish a message

```bash
curl -X POST http://localhost:3000/api/v1/queues/my-queue/messages \
	-H 'Content-Type: application/json' \
	-d '{"body":"Hello from curl"}'
```

- Receive messages (max N)

```bash
curl 'http://localhost:3000/api/v1/queues/my-queue/messages?max=5' | jq
```

- Ack a message

```bash
curl -X POST http://localhost:3000/api/v1/queues/my-queue/messages/ack \
	-H 'Content-Type: application/json' \
	-d '{"message_id":"<MESSAGE_ID>"}' -v
```

See the Swagger UI for complete request/response schemas.

## Library Usage (Rust)

You can use the broker programmatically (for embedding, tests, or integration):

```rust
use flowq_core::Broker;
use flowq_storage::MemoryStorage;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
		let storage = MemoryStorage::new();
		let broker = Broker::new(storage);

		// Create queue
		broker.create_queue("demo").await?;

		// Publish
		let msg_id = broker.publish_bytes("demo", "hello world").await?;

		// Receive
		let msg = broker.receive("demo").await?;

		println!("Received: {:?}", msg);
		Ok(())
}
```

## Testing

Run unit tests for the whole workspace:

```bash
cargo test --workspace
```

Individual crates include tests for `MemoryStorage` and `Broker` behavior.

## Contributing

- Open issues or PRs with clear summaries and small, focused changes.
- Add unit tests for logic changes.
- If you add a storage backend, implement the `StorageEngine` trait in [crates/flowq-storage/src/traits.rs](crates/flowq-storage/src/traits.rs) and add it behind a feature flag.

## Roadmap / Next Steps

- Durable storage backends (SQLite, PostgreSQL)
- Persistent message indexes and disk-backed queues
- Dead-letter queue support and metrics
- TLS, authentication and authorization for the HTTP API
- Clustering / replication for HA

## License

This project uses the workspace license: `MIT OR Apache-2.0` (see [Cargo.toml](Cargo.toml)).

---

If you'd like, I can also:

- Add usage examples as integration tests or a small example app in `examples/`.
- Add a `Makefile` or simple PowerShell script for common dev tasks.
- Generate a short CONTRIBUTING.md with contribution checklist.

Which of these would you like next?
