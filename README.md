# FlowQ — Open-Source Azure Service Bus Alternative (Rust Message Broker)

**FlowQ is an open-source, self-hosted alternative to Azure Service Bus.**
A lightweight message broker written in Rust, designed for developers who want simple pub/sub and queue semantics without cloud lock-in.

[![License](https://img.shields.io/badge/license-MIT%2FApache--2.0-blue.svg)](LICENSE)
[![Rust](https://img.shields.io/badge/rust-1.75%2B-orange.svg)](https://www.rust-lang.org/)

**Status:** MVP — in-memory storage, HTTP API, OpenAPI/Swagger, basic QoS (ack/nack, visibility timeout, retries).

---

## Who is FlowQ for?

FlowQ is ideal for:

- **Developers** looking for an open-source Azure Service Bus alternative
- **Microservice architectures** needing simple queues and pub/sub messaging
- **Local development and testing** without cloud dependencies or costs
- **Teams building event-driven systems** in Rust, Node.js, Python, Go (via HTTP API)
- **Startups & indie developers** who want cost-effective messaging infrastructure

---

## How FlowQ Compares — Azure Service Bus vs RabbitMQ vs FlowQ

| Feature            | FlowQ | Azure Service Bus | RabbitMQ   | Kafka |
| ------------------ | ----- | ----------------- | ---------- | ----- |
| Open source        | ✅    | ❌                | ✅         | ✅    |
| Self-hosted        | ✅    | ❌                | ✅         | ✅    |
| Single binary      | ✅    | ❌                | ❌         | ❌    |
| Zero config startup| ✅    | ❌                | ❌         | ❌    |
| Lightweight        | ✅    | ❌                | ❌         | ❌    |
| Written in Rust    | ✅    | ❌                | ❌         | ❌    |
| HTTP/REST API      | ✅    | ✅                | Via plugin | ❌    |
| Swagger/OpenAPI    | ✅    | ✅                | ❌         | ❌    |
| Cloud lock-in      | ❌    | ✅                | ❌         | ❌    |
| MVP-friendly       | ✅    | ❌                | ❌         | ❌    |

---

## Common Use Cases

- **Replacing Azure Service Bus** in local development environments
- **Lightweight event bus** for microservices communication
- **Queue-based background job processing**
- **Prototyping event-driven architectures**
- **Message queue for side projects** without cloud costs
- **Testing pub/sub patterns** without external dependencies

---

## Overview — An Open-Source Azure Service Bus Alternative

FlowQ provides:

- **Lightweight queue creation** with named queues
- **Publish/consume semantics** for message passing
- **Message acknowledgement** (ack/nack) with retry behavior
- **Per-queue configuration** (visibility timeout, TTL, max retries)
- **In-memory storage backend** suitable for development and tests
- **HTTP API** with autogenerated OpenAPI and Swagger UI

This project is intentionally modular: core logic, types, storage backends, and server are split into separate crates so you can replace storage or extend features independently.

---

## Features

- Create, list, and delete named queues
- Publish messages (raw text/bytes or JSON)
- Receive single or batched messages
- Ack / Nack messages with configurable retry behavior
- Queue-level configuration (visibility timeout, TTL, max retries, dead letter queue)
- Message priority support (1-10)
- In-memory storage backend (default)
- HTTP REST API with OpenAPI 3.1 specification
- Interactive Swagger UI documentation

---

## Quick Start

### Prerequisites

- Rust toolchain (stable, 1.75+)

### Build & Run

```bash
# Clone the repository
git clone https://github.com/YOUR_USERNAME/flowq.git
cd flowq

# Build
cargo build --workspace

# Run the server
cargo run -p flowq-server
```

Server starts on `http://localhost:3000`

### Access Points

| Endpoint                                        | Description                   |
| ----------------------------------------------- | ----------------------------- |
| <http://localhost:3000/swagger-ui/>             | Interactive API documentation |
| <http://localhost:3000/health>                  | Health check endpoint         |
| <http://localhost:3000/api/v1/queues>           | Queue management API          |

---

## HTTP API Examples

### Health Check

```bash
curl http://localhost:3000/health
```

### Create a Queue

```bash
curl -X POST http://localhost:3000/api/v1/queues \
  -H 'Content-Type: application/json' \
  -d '{"name":"orders"}'
```

### Publish a Message

```bash
curl -X POST http://localhost:3000/api/v1/queues/orders/messages \
  -H 'Content-Type: application/json' \
  -d '{"body":"Hello FlowQ!", "priority": 5}'
```

### Receive Messages

```bash
curl 'http://localhost:3000/api/v1/queues/orders/messages?max=10'
```

### Acknowledge a Message

```bash
curl -X POST http://localhost:3000/api/v1/queues/orders/messages/ack \
  -H 'Content-Type: application/json' \
  -d '{"message_id":"<MESSAGE_ID>"}'
```

### Get Queue Statistics

```bash
curl http://localhost:3000/api/v1/queues/orders/stats
```

See the [Swagger UI](http://localhost:3000/swagger-ui/) for complete API documentation.

---

## High-Level Architecture

```text
┌─────────────────────────────────────────────────────────┐
│                    HTTP Clients                         │
│         (curl, Postman, your app, SDKs)                │
└────────────────────────┬────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────┐
│              flowq-server (Axum HTTP)                   │
│           REST API + Swagger UI + OpenAPI               │
└────────────────────────┬────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────┐
│                  flowq-core (Broker)                    │
│        Queue management, message processing,            │
│           ack/nack, visibility timeout                  │
└────────────────────────┬────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────┐
│             flowq-storage (Storage Engine)              │
│    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│    │   Memory    │  │   SQLite    │  │ PostgreSQL  │   │
│    │   (MVP)     │  │  (planned)  │  │  (planned)  │   │
│    └─────────────┘  └─────────────┘  └─────────────┘   │
└─────────────────────────────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────┐
│               flowq-types (Shared Types)                │
│          Message, Queue, QueueConfig, Error             │
└─────────────────────────────────────────────────────────┘
```

---

## Repository Layout

```text
flowq/
├── Cargo.toml                    # Workspace manifest
├── crates/
│   ├── flowq-types/              # Shared domain types
│   │   └── src/
│   │       ├── message.rs        # Message struct
│   │       ├── queue.rs          # Queue, QueueConfig, QueueStats
│   │       └── error.rs          # Error types
│   ├── flowq-storage/            # Storage backends
│   │   └── src/
│   │       ├── traits.rs         # StorageEngine trait
│   │       └── memory.rs         # In-memory implementation
│   ├── flowq-core/               # Core broker logic
│   │   └── src/
│   │       └── broker.rs         # Broker implementation
│   └── flowq-server/             # HTTP server
│       └── src/
│           └── main.rs           # Axum server + routes
```

---

## Library Usage (Rust)

Use the broker programmatically for embedding, tests, or integration:

```rust
use flowq_core::Broker;
use flowq_storage::MemoryStorage;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let storage = MemoryStorage::new();
    let broker = Broker::new(storage);

    // Create queue
    broker.create_queue("demo").await?;

    // Publish
    let msg_id = broker.publish_bytes("demo", b"hello world").await?;

    // Receive
    let messages = broker.receive("demo", 1).await?;
    println!("Received: {:?}", messages);

    // Acknowledge
    broker.ack("demo", &msg_id).await?;

    Ok(())
}
```

---

## Testing

Run all tests:

```bash
cargo test --workspace
```

Current test coverage:

- `flowq-types`: 5 tests (serialization, validation)
- `flowq-storage`: 4 tests (memory backend operations)
- `flowq-core`: 4 tests (broker logic)

---

## Roadmap — Building Toward Production-Ready

FlowQ aims to grow into a production-ready, cloud-agnostic message broker.

### Phase 2: Persistence (Next)

- [ ] SQLite storage backend
- [ ] Write-Ahead Log (WAL) for durability
- [ ] Crash recovery

### Phase 3: Advanced Features

- [ ] Dead Letter Queue (DLQ) implementation
- [ ] Delayed/scheduled messages
- [ ] Message deduplication engine
- [ ] Consumer groups

### Phase 4: Topics & Pub/Sub

- [ ] Topic support with fan-out
- [ ] Subscription management
- [ ] Filter expressions

### Phase 5: Production Hardening

- [ ] PostgreSQL backend
- [ ] TLS/HTTPS support
- [ ] Authentication & authorization
- [ ] Prometheus metrics endpoint
- [ ] Clustering / HA

### Phase 6: SDKs

- [ ] Python SDK
- [ ] Node.js SDK
- [ ] Go SDK

---

## Contributing

We welcome contributions! Here's how to help:

1. **Open issues** with clear descriptions and reproduction steps
2. **Submit PRs** with focused, small changes
3. **Add tests** for any logic changes
4. **Implement storage backends** by implementing the `StorageEngine` trait

To add a new storage backend:

1. Implement `StorageEngine` trait in `crates/flowq-storage/src/`
2. Add it behind a feature flag
3. Add tests

---

## License

Dual-licensed under MIT or Apache-2.0. See [Cargo.toml](Cargo.toml) for details.

---

## Support & Community

- **GitHub Issues**: Bug reports and feature requests
- **Discussions**: Questions and ideas
- **Star this repo** if you find it useful!

---

**Built with Rust** for performance, safety, and reliability.
